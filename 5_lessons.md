2. Введение в язык JavaScript для новичков
   1.

---

### Основы работы с пользовательскими функциями в JavaScript

Сейчас мы с вами научимся создавать свои функции, которые затем можно будет использовать подобно стандартным функциям и методам JavaScript. Давайте рассмотрим синтаксис для создания своей функции.

Функция создается с помощью команды `function`. Далее через пробел следует имя функции, круглые скобки, а затем фигурные скобки, в которых пишется какой-то код:

```js
functionfunc(){// какой-то код
}
```

Давайте посмотрим на каком-нибудь примере. Сделаем функцию с именем `func`, которая при своем вызове будет выводить алертом восклицательный знак:

```js
functionfunc(){console.log('!');}
```

Давайте теперь вызовем нашу функцию. Для этого необходимо написать ее имя и круглые скобки:

```js
functionfunc(){console.log('!');}// Вызываем нашу функцию:func();// выведет '!'
```

Можно вызвать нашу функцию несколько раз - в этом случае каждый вызов функции будет выдавать новый алерт:

```js
functionfunc(){console.log('!');}func();// выведет '!'func();// выведет '!'func();// выведет '!'
```

Функции могут быть вызваны до места своего определения:

```js
func(); // выведет '!'functionfunc(){console.log('!');}
```

---

### Параметры функций в JavaScript

Функции могут принимать параметрами данные. Для примера давайте сделаем функцию, которая параметром будет принимать число:

```js
functionfunc(num){}
```

Давайте сделаем так, чтобы функция возводила переданное число в квадрат:

```js
functionfunc(num){console.log(num**2);}
```

Проверим работу функции, вызвав ее с различными числами:

```js
func(2); // выведет 4func(3);// выведет 9
```

---

### Несколько параметров функций в JavaScript

Функция может принимать не один параметр, а несколько. В этом случае их нужно перечислить через запятую. Давайте для примера сделаем функцию, параметром принимающую два числа и выводящую в консоль их сумму:

```js
function func(num1, num2) {
	console.log(num1 + num2);
}
```

Проверим работу нашей функции:

```js
func(1, 2); // выведет 3
```

---

### Параметры-переменные функций в JavaScript

В параметры функции можно передавать переменные. Давайте посмотрим на примере. Пусть у нас есть следующая функция:

```js
function func(num) {
	console.log(num ** 2);
}
```

Пусть у нас есть переменная:

```js
let param = 2;

// Вызовем нашу функцию, передав ей параметром число из переменной:
let param = 2;
func(param);
```

---

### Необязательные параметры в JavaScript

Параметры функций можно делать не обязательными. Для этого параметрам нужно задать значения по умолчанию. Пусть для примера у нас есть следующая функция:

```js
function func(num) {
	console.log(num ** 2);
}
```

Давайте сделаем так, чтобы этот параметр по умолчанию имел значение 0:

```js
function func(num = 0) {
	console.log(num ** 2);
}

// Проверим работу нашей функции с параметром:
func(2); // выведет 4

// Проверим работу нашей функции без параметра:
func(); // выведет 0
```

---

### Инструкция return в JavaScript

Пусть у нас есть функция, которая выводит в консоль квадрат переданного числа:

```js
function func(num) {
	console.log(num ** 2);
}
```

Пусть мы хотим не выводить значение в консоль, а записать в какую-нибудь переменную, вот так:

```js
let res = func(3); // в переменной res теперь 9
```

Для этого в JavaScript существует специальная инструкция **return**, которая позволяет указать значение, которое возвращает функция. Под словом "возвращает" понимают то значение, которое запишется в переменную, если ей присвоить вызванную функцию.

Итак, давайте перепишем нашу функцию так, чтобы она не выводила результат в консоль, а возвращала его в переменную:

```js
function func(num) {
	return num ** 2;
}

// Вызовем теперь нашу функцию, записав ее ответ в переменную:
let res = func(3); // в переменную запишется 9

// После того, как данные записаны в переменную, их можно, например, вывести в консоль:
let res = func(3);
console.log(res); // выведет 9

// А можно сначала как-то изменить эти данные, а затем вывести их в консоль:
let res = func(3);
res = res + 1;
console.log(res); // выведет 10

// Можно сразу выполнять какие-то действия с результатом работы функции перед записью в переменную:
let res = func(3) + 1;
console.log(res); // выведет 10

// А можно не записывать результат в переменную, а сразу вывести его в консоль:
console.log(func(3)); // выведет 9

// Можно вызвать функцию в одном выражении с различными параметрами:
let res = func(2) + func(3);
console.log(res); // выведет 13
```

---

### Последовательный вызов функций в JavaScript

Можно результат работы одной функции передать параметром в другую. В следующем примере мы сначала найдем квадрат числа 2, а затем квадрат результата:

```js
function func(num) {
	return num ** 2;
}

let res = func(func(2));
console.log(res); // выведет 16
```

Функции, конечно же, не обязательно должны быть одинаковыми. Пусть, например, у нас есть функция, возвращающая квадрат числа, и функция, возвращающая куб числа:

```js
function square(num) {
	return num ** 2;
}

function cube(num) {
	return num ** 3;
}
```

Давайте с помощью этих функций возведем число 2 в квадрат, а затем результат этой операции возведем в куб:

```js
let res = cube(square(2));
console.log(res);

// Пусть теперь у нас есть функция, возвращающая квадрат числа, и функция, находящая сумму двух чисел:
function square(num) {
	return num ** 2;
}

function sum(num1, num2) {
	return num1 + num2;
}

// Найдем с помощью этих функций сумму квадрата числа 2 и квадрата числа 3:
let res = sum(square(2), square(3));
console.log(res);
```

---

### Тонкое место return в JavaScript

После того, как выполнится инструкция return - функция закончит свою работу и никакой код дальше не выполнится. Смотрите пример:

```js
function func(num) {
	return num ** 2;
	console.log("!"); // этот код никогда не выполнится
}

let res = func(3);
```

Это не значит, что в функции должен быть один return. Но выполнится только один из них. В следующем примере в зависимости от значения параметра выполнится либо первый, либо второй return:

```js
function func(num) {
	if (num >= 0) {
		return "+++";
	} else {
		return "---";
	}
}

console.log(func(3)); // выведет '+++'
console.log(func(-3)); // выведет '---'
```

---

### Цикл и return в JavaScript

Пусть у нас есть функция, возвращающая сумму чисел от 1 до 5:

```js
function func() {
	let sum = 0;
	for (let i = 1; i <= 5; i++) {
		sum += i;
	}
	return sum;
}

let res = func();
console.log(res); // выведет 15
```

Пусть теперь мы расположим return внутри цикла, вот так:

```js
function func() {
	let sum = 0;
	for (let i = 1; i <= 5; i++) {
		sum += i;
		return sum;
	}
}

let res = func();
console.log(res);
```

В этом случае цикл прокрутится лишь одну итерацию и произойдет автоматический выход из функции (ну и заодно из цикла). А за одну итерацию цикла в переменной sum окажется лишь число 1, а не вся нужная сумма.

---

### Применение return в циклах в JavaScript

То, что return расположен внутри цикла, не всегда может быть ошибкой. В следующем примере сделана функция, которая определяет, сколько первых элементов массива нужно сложить, чтобы сумма стала больше или равна 10:

```js
function func(arr) {
	let sum = 0;
	for (let i = 0; i < arr.length; i++) {
		sum += arr[i];
		// Если сумма больше или равна 10:
		if (sum >= 10) {
			return i + 1; // выходим из цикла и из функции
		}
	}
}

let res = func([1, 2, 3, 4, 5]);
console.log(res);
```

А в следующем примере сделана функция, которая вычисляет, сколько целых чисел, начиная с 1, нужно сложить, чтобы результат был больше 100:

```js
function func() {
	let sum = 0;
	let i = 1;
	while (true) {
		// бесконечный цикл
		sum += i;
		if (sum >= 100) {
			return i; // цикл крутится пока не выйдет тут
		}
		i++;
	}
}

console.log(func());
```

---

### Прием работы с return в JavaScript

Существуют некоторые приемы работы с return, упрощающие код. Рассмотрим, к примеру, следующий код:

```js
function func(num) {
	let res;
	if (num >= 0) {
		res = Math.sqrt(num);
	} else {
		res = 0;
	}
	return res;
}

console.log(func(3));
```

Как вы видите, в данном коде в зависимости от условия в переменную res будет попадать либо одно, либо другое значение. А последней строкой функции содержимое переменной res возвращается через return.

Давайте перепишем этот код в более сокращенной форме, избавившись от ненужной здесь переменной res:

```js
function func(num) {
	if (num >= 0) {
		return Math.sqrt(num);
	} else {
		return 0;
	}
}

console.log(func(3));
```

---

Флаги в функциях JavaScript

В функциях можно использовать флаги в неявном виде с помощью инструкции return. Давайте посмотрим, как это делается. Пусть у нас есть следующая функция, проверяющая, что все элементы массива положительные числа:
function isPositive(arr) {
let flag = true;
for (let elem of arr) {
if (elem < 0) {
flag = false;
}
}
return flag;
}

Давайте перепишем код функции с помощью неявного использования флагов:
function isPositive(arr) {
for (let elem of arr) {
if (elem < 0) {
return false;
}
}
return true;
}

Как это работает: если в массиве найдется нужный элемент - мы выйдем из функции (и из цикла тоже) с помощью return. Но если в массиве не найдется нужный элемент - выхода из функции не произойдет и выполнение дойдет до команды return true. И получится, что функция вернет true в знак того, что в массиве все элементы положительные.

---

Логические операторы без if в функциях JavaScript

Пусть у нас есть функция с ифом. Вот она:
function func(a, b) {
if (a > b) {
return true;
} else {
return false;
}
}

Как вы уже знаете из предыдущих уроков, конструкции if, возвращающие булевы значения, можно переписывать в сокращенной форме. Давайте сделаем это:
function func(a, b) {
return a > b;
}

---

Советы по созданию функций в JavaScript

    Имена функций должны быть глаголами.
    Имя каждой функции должно точно отражать то, что функция делает.
    Функция должна делать только то, что явно подразумевается её названием, и не делать другого.
    Каждая функция должна выполнять только одно действие.
    Используйте внутри функций вспомогательные функции.
    Код функций лучше не делать длиннее 10-15 строк.
    Длинные функции лучше разбивать на ряд вспомогательных.
    Используйте общепринятые префиксы в именах функций: show, get, set, calc, create, change, check.
    Выносите дублирующийся код в функции.

---

Глобальные переменные в функциях в JavaScript

В JavaScript (в других языках чаще всего не так) переменные, определенные снаружи функции, будут видны внутри этой функции. Такие переменные называются глобальными. Посмотрим на примере:
let num = 1; // переменная снаружи функции

function func() {
console.log(num); // переменная num видна внутри функции
}

func(); // выведет 1

На самом деле переменная должна быть определена не перед определением функции, а перед ее вызовом:
function func() {
console.log(num);
}

let num = 1; // переменная снаружи функции
func(); // выведет 1

Если менять значение переменной и после этого каждый раз вызывать функцию - алерт каждый раз будет выдавать разные результат:
function func() {
console.log(num);
}

let num; // объявим переменную

num = 1; // задаем значение 1
func(); // выведет 1

num = 2; // задаем значение 2
func(); // выведет 2

Если у нас несколько функций, то глобальная переменная будет доступна в каждой из этих функций:
function func1() {
console.log(num);
}

function func2() {
console.log(num);
}

let num = 1;

func1(); // выведет 1
func2(); // выведет 1

Если в одной из функций произойдут изменения с глобальной переменной, то эта переменная поменяется во всех функциях, использующих эту переменную:
function func1() {
console.log(num);
num++; // меняем глобальную переменную
}

function func2() {
console.log(num);
}

let num = 1;

func1(); // выведет 1
func2(); // выведет 2

Так как любая из функций легко может поменять глобальную переменную, то их использование представляет собой рассадник трудноуловимых ошибок. По этой причине использование глобальных переменных в скрипте нужно сводить к минимуму. Желательно, чтобы их вообще не было или было самое минимальное количество.

---

Локальные переменные в функциях в JavaScript

Переменные, определенные внутри функции, называются локальными. В отличии от глобальных переменных, локальные переменные видны только внутри функции, и не видны снаружи:
function func() {
let num = 5; // локальная переменная
console.log(num);
}

console.log(num); // ничего не выведет, а выдаст ошибку в консоль

---

Одинаковые имена переменных в функциях в JavaScript

Пусть и снаружи функции, и внутри есть переменная num. В этом случае любые изменения с локальной переменной num никак не влияют на глобальную переменную num:
let num = 1; // глобальная переменная

function func() {
let num = 2; // локальная переменная
console.log(num);
}
func(); // вызываем функцию, выведет 2

console.log(num); // выведет 1 - глобальная переменная не поменялась

Но, если мы забудем объявить локальную переменную num через let, то внутри функции не создастся локальная переменная num, а просто изменится глобальная переменная:
let num = 1;

function func() {
num = 2; // забыли написать let - меняем внешнюю переменную
console.log(num);
}
func(); // вызываем функцию, выведет 2

console.log(num); // выведет 2 - переменная поменялась

Тут может быть две ситуации: или мы действительно хотели поменять глобальную переменную (тогда все ок), или мы забыли let и случайно поменяли глобальную переменную.

Второй случай является трудноуловимой ошибкой, ведущей к непредсказуемому поведению скрипта. Поэтому всегда, вводя новую переменную объявляйте ее через let.

---

Изменение глобальных переменных в JavaScript

Учтите, что глобальная переменная будет меняться только в момент вызова функции. Если вызова функции нет - переменная не изменится:
let num = 1;

function func() {
num = 2; // не написан let - меняем внешнюю переменную
console.log(num);
}
// func(); - закомментировали вызов функции

console.log(num); // выведет 1 - переменная не поменялась

А сейчас продемонстрируем кодом то, что глобальная переменная поменяется только после вызова функции:
let num = 1;

function func() {
num = 2;
}

console.log(num); // выведет 1
func(); // меняем переменную
console.log(num); // выведет 2

---

Глобальные переменные и параметры функций в JavaScript

Пусть у нас есть функция, принимающая параметром число:
function func(localNum) {
console.log(localNum);
}

Пусть снаружи функции есть переменная num:
function func(localNum) {
console.log(localNum);
}

let num = 1; // внешняя глобальная переменная

Давайте вызовем нашу функцию, передав ей параметром переменную num:
function func(localNum) {
console.log(localNum);
}

let num = 1;
func(num); // вызываем функцию с параметром, выведет 1

Получится, что внутри функции будет доступна как переменная localNum (параметр функции), так и переменная num (как внешняя переменная):
function func(localNum) {
console.log(num); // выведет 1
console.log(localNum); // выведет 1
}

let num = 1;
func(num);

Сама переменная localNum будет локальной переменной функции и не будет доступна извне:
function func(localNum) {
}

let num = 1;
func(num); // вызываем функцию с параметром
console.log(localNum); // выдаст ошибку

Так как переменная localNum - локальная, то никакие изменения с ней ничего не поменяют снаружи:
function func(localNum) {
localNum = 2; // ничего не меняет снаружи
}

let num = 1;
func(num);

Если же поменять внутри переменную num (глобальную), то изменения появятся и снаружи:
function func(localNum) {
num = 2;
}

let num = 1;
func(num);
console.log(num); // выведет 2

Однако, если внутри функции объявить переменную num через let, то мы создадим таким образом локальную переменную num, никак не влияющую на внешнюю переменную:
function func(localNum) {
let num = 2; // объявим через let
}

let num = 1;
func(num);
console.log(num); // выведет 1 - ничего не поменялось

---

Совпадение имен с параметрами в JavaScript

Параметры функции являются локальными переменными внутри нее. Давайте назовем параметр функции таким же именем, как и внешнюю глобальную переменную:
function func(num) {
console.log(num);
}

let num = 1;
func(num);

В данном случае у нас получится так, что снаружи функции будет переменная num и внутри функции будет переменная num. Но это будут разные переменные: изменение переменной внутри функции будет приводить к изменению локальной переменной функции. А внешняя переменная внутри функции будет недоступна и не сможет быть изменена никаким способом. Проверим:
function func(num) {
num = 2; // меняем локальную переменную
}

let num = 1;
func(num);
console.log(num); // выведет 1 - ничего не поменялось

---

Параметры-объекты JavaScript

Объекты, в отличие от примитивов, передаются по ссылке. Это значит, что изменение объекта внутри функции приведет к тому, что он поменяется и снаружи функции. Смотрите пример:
function func(arr) {
arr[0] = '!';
}

let arr = [1, 2, 3];
func(arr);
console.log(arr); // выведет ['!', 2, 3]

---

Исходный код функции и ее результат в JavaScript

В JavaScript можно написать имя функции без круглых скобок. В этом случае мы увидим не результат работы функции, а ее исходный код.

Давайте попробуем. Пусть у нас есть какая-то функция, например, такая:
function func() {
return '!';
}

Давайте вызовем эту функцию, написав ее имя и круглые скобки. В этом случае мы увидим результат работы функции:
function func() {
return '!';
}

console.log(func()); // выведет '!'

А теперь давайте попробуем опустить после имени функции круглые скобки. В этом случае мы увидим исходный код нашей функции:
function func() {
return '!';
}

console.log(func); // увидим код функции

---

Функция как переменная в JavaScript

Итак, в предыдущем уроке мы с вами выяснили, что обратившись к функции без круглых скобок, мы получаем ее исходный код.

На самом деле все намного интереснее. В JavaScript, в отличие от других языков, функции являются такими же значениями переменных, как числа, строки и массивы.

Давайте посмотрим на примере. Пусть у нас есть, например, функция func:
function func() {
console.log('!');
}

На самом деле у нас нет функции func. У нас есть переменная func, хранящая в себе исходный код функции.

Мы можем, к примеру, затереть переменную func чем-нибудь другим, например, строкой. В этом случае функция func больше не будет функцией, а будет строкой. Смотрите на примере:
function func() {
console.log('!');
}
func(); // выведет '!'

func = 'string'; // затрем переменную func
console.log(func); // выведет 'string'

---

Запись функции в другую переменную в JavaScript

Пусть у нас есть наша функция func:
function func() {
console.log('!');
}

Давайте скопируем ее исходный код в переменную test:
function func() {
console.log('!');
}

let test = func; // теперь test такая же функция, как и func

// Проверим:
test(); //выведет '!'
func(); //выведет '!'

---

Присваивание функций в переменные в JavaScript

Итак, мы с вами уже выяснили, что название функции и ее исходный код отделены друг от друга. Поэтому в JavaScript существует альтернативный синтаксис для создания функции: создается функция без имени и присваивается в какую-нибудь переменную. Эта переменная и становится именем функции.

Давайте посмотрим на примере:
let func = function() {
console.log('!');
};

func(); // выведет '!'

---

Совпадение имени функции и переменной в JavaScript

Из описанного выше следует, что существование переменной и функции с одинаковым именем легко может привести к проблеме.

В следующем примере функция func будет затерта и вместо нее станет строка 'string':
function func() {
return '!';
}

func = 'string'; // затрем переменную с функцией строкой
func(); // получим ошибку, т.к. func - не функция

Чтобы такого не происходило, следует придерживаться правила, общего для всех языков программирования: функции должны быть глаголами, а переменные - существительными.

---

Function expression и Function declaration в JavaScript

В JavaScript функцию можно объявить двумя способами.

Первый способ - это просто объявить функцию через function, сразу задав ее имя:
function func() {
console.log('!');
}

func(); // выведет '!'

Второй способ - это сделать безымянную функцию и записать ее в какую-либо переменную:
let func = function() {
console.log('!');
};

func(); // выведет '!'

По научному первый способ называется Function Declaration (объявление функции), а второй - Function Expression (функциональное выражение).

---

Разница объявлений функции

Оба способа объявления функции эквивалентны, но есть существенная разница: функции, объявленные как Function Declaration, будут доступны, даже если обратится к ним до того, как они были объявлены.

Смотрите пример:
// Обращаемся к функции до ее объявления:
func(); //выведет '!'

function func() {
console.log('!');
}

А функциональные выражения создаются в момент выполнения кода и недоступны выше. Поэтому такой код выдаст ошибку:
func(); //ошибка, такой функции еще нет!

let func = function() {
console.log('!');
};

---

Точка с запятой при объявлении функций в JavaScript

При объявлении функции как Function Declaration после фигурной скобки } точка с запятой не ставится:
function func() {
console.log('!');
}

Если же функция объявлена Function Expression, то после } ставится точка с запятой:
let func = function() {
console.log('!');
};

Почему: потому что в JavaScript любое выражение должно заканчиваться точкой с запятой, а в данном случае у нас как раз-таки выражение. Эта точка с запятой не обязательна, так как JavaScript вообще разрешает их не ставить, но желательна. Ставьте всегда:)

---

Нюансы функциональных выражений в JavaScript

Название Function Expression (функциональное выражение) дано не просто так. Оно действительно означает это - то, что такие функции являются частью какого-либо выражения.

Например, мы можем сложить какую-нибудь строку и безымянную функцию:
let str = 'str' + function() {return 3;};
console.log(str); // выведет 'strfunction() {return 3;}'

Почему мы видим такой странный результат, а не число 3? Потому что второе слагаемое - это не результат работы функции, а ее исходный код (ведь мы эту функцию не вызвали, а просто написали).

То есть название функциональное выражение обозначает то, что такая функция принимает участие в каком-нибудь выражении.

Присваивание к переменной тоже выражение:
let func = function() {
console.log('!');
};

Можно также, к примеру, передать функцию в качестве параметра алерта и он выведет ее исходный код в консоль - это тоже будет считаться выражением:
console.log(function() {return 3;});

Почему это важно: потому что отличие Function Declaration и Function Expression совсем не в том, что первая функция создается с именем, а вторая изначально имени не имеет. Это не так.

Пример. Вот у нас функция без имени, но при этом не участвует ни в каком выражении (то есть с ней не совершается никаких действий, говоря по-простому):
/_
Данная функция будет Function Declaration,
но с синтаксической ошибкой:
_/
function() {
console.log('!');
}

Такой код вообще выдаст ошибку! Почему: так как функция не участвует ни в каком выражении, то браузер считает ее Function Declaration, но не находит ее имени и выдает ошибку.

Чтобы ошибка исчезла, нужно заставить функцию стать частью какого-либо выражения. Например, напишем перед ней операцию +:
+function() { // такой код корректен
console.log('!');
};

Как это работает: сама по себе операция + ничего не делает, это все равно как написать вместо числа 3 число +3 - допустимо, но ничего не меняет.

Но в случае с функцией - меняет. Теперь наша функция уже не просто написана, а участвует в выражении. Поэтому ошибки теперь не будет. Результата выполнения функции тоже не будет, ведь мы ее просто написали, но не вызвали.

Вместо + можно написать все, что угодно. Например:
-function() { // такой код корректен
console.log('!');
};

!function() { // такой код корректен
console.log('!');
};

Можно также взять нашу функцию в круглые скобки, в этом случае она также станет функциональным выражением:
(function() { // такой код корректен
console.log('!');
});

---

Именованные функциональные выражения в JavaScript

Пусть у нас есть вот такое функциональное выражение:
let test = function() {
console.log('!');
};

test(); // выведет '!'

Давайте нашей функции дадим имя func:
let test = function func() {
console.log('!');
};

test();

Как вы уже знаете, по этому имени не обратиться к функции:
let test = function func() {
console.log('!');
};

test(); // выведет '!'
func(); // выдаст ошибку

Зачем же давать имя функции, если оно не будет доступно? Дело в том, что это имя будет недоступно снаружи функции, но доступно внутри этой функции.

Давайте проверим:
let test = function func() {
console.log(func); // функция выведет свой же исходный код
};

test(); // вызываем функцию

Давайте вызовем нашу функцию внутри нее самой:
let test = function func() {
console.log('!'); // выводим '!'
func(); // вызываем сами себя
};

test();

Если запустить данный код, то в консоль будет выводится бесконечное количество выводов в консоль.

На самом деле наша функция может быть вызвана внутри себя не только как func, но и как test:
let test = function func() {
console.log('!');
test(); // вызываем сами себя
};

test();

В чем же разница? Разница в том, что имя test - это просто переменная. В процессе работы скрипта наша функция может записаться в другую переменную или предаться параметром - в этом случае связь между переменной test и функцией может пропасть.

Имя func же жестко привязано к функции специально для того, чтобы можно было обратиться к нашей функции внутри нее самой.

Такие Function Expression с именем функции называются именованными функциональными выражениями.

---

Как проверить тип функции в JavaScript

В задачах ниже вам нужно будет определить функция определена как Function Declaration или Function Expression.

В простых случаях это не составляет труда сделать визуально. Но как проверить, что вы сделали это правильно? Используйте разницу между Function Declaration или Function Expression: первые могут быть вызваны выше своего определения, а вторые - нет.

Пусть у нас есть вот такая функция:
let test = function() {
console.log('!');
}

Обратимся к этой функции до ее определения:
test(); // выведет ошибку в консоль, значит Function Expression

let test = function() {
console.log('!');
}

Вот еще пример:
func(); // выведет '!', значит Function Declaration

function func() {
console.log('!');
}

Поставим перед нашей функцией плюсик:
func(); // выведет ошибку в консоль, значит Function Expression

+function func() {
console.log('!');
}

Так как функция выше - это Function Expression и она не присвоена никакой переменной, то ее никак не вызвать, ведь по имени func она будет недоступна.

---

Массив с анонимными функциями в JavaScript

Я уже упоминал ранее, что функции в JavaScript ведут себя, будто строки или числа. В частности, можно сделать массив, состоящий из функций. Сделаем:
let arr = [
function() {console.log('1')},
function() {console.log('2')},
function() {console.log('3')},
];

Давайте, например, выведем в консоль содержимое нулевого элемента массива:
let arr = [
function() {console.log('1')},
function() {console.log('2')},
function() {console.log('3')},
];

console.log(arr[0]); // увидим исходный код первой функции

Как вы видите, в примере выше мы получаем исходный код функции, а не результат.

Чтобы происходил вызов функции, к ней нужно дописать круглые скобки. Так как наша функция хранится в arr[0], то круглые скобки нужно будет написать после квадратных, вот так: arr[0](). Проверим:
let arr = [
function() {console.log('1')},
function() {console.log('2')},
function() {console.log('3')},
];

arr[0](); // выведет '1'

Можно также перебрать наш массив с функциями циклом и в этом цикле вызвать каждую из функций:
let arr = [
function() {console.log('1')},
function() {console.log('2')},
function() {console.log('3')},
];

for (let func of arr) {
func(); // вызываем наши функции в цикле
}

---

Объект с анонимными функциями в JavaScript

В предыдущем уроке мы с вами делали массив, состоящий из функций. Давайте теперь вместо массива сделаем объект с ключами, значениями которых будут функции:
let obj = {
func1: function() {console.log(1)},
func2: function() {console.log(2)},
func3: function() {console.log(3)},
};

Воспользуемся нашим объектом:
let obj = {
func1: function() {console.log(1)},
func2: function() {console.log(2)},
func3: function() {console.log(3)},
};

obj.func1(); // выведет 1

---

Область видимости вложенных функций в JavaScript

Если функция содержит внутри другую функцию - переменные внешней функции видны во внутренней:
function test() {
let num = 1; // переменная внешней функции
function func() {
console.log(num); // выведет 1
}
func(); // вызываем внутреннюю функцию
}

test(); // вызываем внешнюю функцию

Также во внутренней функции будут видны переменные, определенные снаружи внешней функции:
let num = 1; // глобальная переменная

function test() {
function func() {
console.log(num); // выведет 1
}
func(); // вызываем внутреннюю функцию
};

test(); // вызываем внешнюю функцию

---

Функции-коллбэки в JavaScript

Функции можно передавать параметрами в другие функции. Такие функции-параметры называются коллбэками (англ. callback). Давайте посмотрим работу с ними на примере.

Пусть мы хотим сделать функцию, которая первым параметром будет принимать массив, а вторым - коллбэк, который будет применять к каждому элементу массива:
function each(arr, callback) {
// тут какой-то код
}

Напишем реализацию нашей функции:
function each(arr, callback) {
let result = [];
for (let elem of arr) {
result.push( callback(elem) ); // вызываем функцию-коллбэк
}
return result;
}

Наша функция each - универсальная. Это значит, что мы можем передавать в нее различные коллбэки, выполняя разные операции над массивами. При этом код нашей функции останется неизменным - будут меняться только передаваемые коллбэки.

Давайте для примера с помощью нашей функции возведем в квадрат каждый элемент какого-нибудь массива. Для этого передадим параметром соответствующий коллбэк:
let result = each([1, 2, 3, 4, 5], function(num) {
return num \*\* 2;
});

console.log(result);

А теперь возведем элементы массива в куб. Для этого в качестве параметра передадим уже другой коллбэк, выполняющий эту операцию:
let result = each([1, 2, 3, 4, 5], function(num) {
return num \*\* 3;
});

console.log(result);

---

Стрелочные функции в JavaScript

Давайте теперь рассмотрим стрелочные функции, упрощающие синтаксис функций.

В следующем примере кода первой написана обычная функция, а второй - соответствующая ей стрелочная (обе функции делают одно и тоже):
let func1 = function(num1, num2) {
let result = num1 \* num2;
return result;
}

let func2 = (num1, num2) => {
let result = num1 \* num2;
return result;
}

Если в функции одна строка кода, то в стрелочных функциях можно не писать return и фигурные скобки:
let func1 = function(num1, num2) {
return num1 \* num2
}

let func2 = (num1, num2) => num1 \* num2;

Если параметр стрелочной функции один - круглые скобки можно не писать:
let func1 = function(num) {
return num \* num;
}

let func2 = num => num \* num

Если в функции вообще нет параметров - нужно писать пустые круглые скобки:
let func1 = function() {
console.log('!!!');
}

let func2 = () => console.log('!!!')

---
