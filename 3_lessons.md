# Содержание

2. Введение в язык JavaScript для новичков
   1. Массивы в JavaScript
   2. Изменение элементов массива в JavaScript
   3. Перезапись элементов массива в JavaScript
   4. Инкремент и декремент элементов массива в JavaScript
   5. Разреженные массивы в JavaScript
   6. Добавление элементов через push в JavaScript
   7. Оператор delete в массивах в JavaScript
   8. Объекты в JavaScript
   9. Свойства объектов в JavaScript
   10. Ограничения на ключи объектов в JavaScript
   11. Изменение элементов объектов в JavaScript
   12. Добавление элементов в объекты в JavaScript
   13. Массив ключей объекта в JavaScript
   14. Длина объекта в JavaScript
   15. Вычисляемые свойства в JavaScript
   16. Оператор in в JavaScript
   17. Оператор delete в JavaScript
   18. Типизация объектов в JavaScript
   19. Отличаем массивы от объектов в JavaScript
   20. Объекты и примитивы в JavaScript
   21. Передача объектов по ссылке в JavaScript
   22. Константы с массивами или объектами в JavaScript
   23. Конструкция if-else в JavaScript
   24. Операторы больше и меньше в JavaScript
   25. Проверка на равенство в JavaScript
   26. Сравнение переменных в JavaScript
   27. Проверка на неравенство в JavaScript
   28. Равенство строк и чисел в JavaScript (не строго стравнение)
   29. Равенство по значению и типу в JavaScript (строго сравнение)
   30. Неравенство по значению и типу в JavaScript
   31. Логическое И в JavaScript
   32. Логическое ИЛИ в JavaScript
   33. Приоритет логических операторов в JavaScript
   34. Группировка условий в JavaScript
   35. Инвертирование логических выражений в JavaScript
   36. Условия с булевыми значениями в JavaScript
   37. Сокращенная форма проверки на истину в JavaScript
   38. Сокращенная форма проверки на ложь в JavaScript
   39. Конструкция else if в JavaScript
   40. Конструкция switch-case в JavaScript
   41. Необязательность break в конструкции switch-case в JavaScript
   42. Тернарный оператор в JavaScript
   43. Область видимости
   44. Область видимости переменных в if-else в JavaScript
   45. Проверка остатка от деления в JavaScript
   46. Задачи на отработку

---

### Массивы в JavaScript

Сейчас мы начнем изучать специальный тип данных, который называется массив. Массив представляет собой переменную, в которой в упорядоченном виде можно хранить целый набор каких-то значений.

Значения, которые хранит массив, называются элементами. Элементы разделяются между собой запятой. После этой запятой принято ставить пробелы.

Для создания массива используются квадратные скобки:

```js
let arr = [];

// Давайте заполним наш массив строками:
let arr = ["a", "b", "c"];

// А теперь заполним массив числами:
let arr = [1, 2, 3];

// Кроме строк и чисел в массиве можно хранить все допустимые типы данных, а также смешивать их между собой в одном массиве, пример:
let arr = [1, 2, "a", "b", null, true, false];
```

Обращение к элементам массива осуществляется подобно обращениям к символам строки. Каждый элемент массива имеет свой номер: первый элемент - номер 0, второй - номер 1 и так далее. Эти номера называются ключами элементов массива. Давайте посмотрим на примере. Пусть у нас дан следующий массив:

```js
let arr = ["a", "b", "c"];

// Давайте выведем его элементы:
console.log(arr[0]); // выведет 'a'
console.log(arr[1]); // выведет 'b'
console.log(arr[2]); // выведет 'c'
```

## **В программировании всё начинается с 0!**

Длина массива находится с помощью свойства length:

```js
let arr = ["a", "b", "c"];
console.log(arr.length); // выведет 3
```

---

### Изменение элементов массива в JavaScript

Элементы массивов можно изменять:

```js
let arr = ["a", "b", "c"];

arr[0] = "!";
console.log(arr); // выведет ['!', 'b', 'c']
```

---

### Перезапись элементов массива в JavaScript

Можно также прочитывать текущее значение элемента, выполнять с ним какие-то операции и записывать измененное значение обратно в этот элемент:

```js
let arr = ["a", "b", "c"];

arr[0] = arr[0] + "!";
arr[1] = arr[1] + "!";
arr[2] = arr[2] + "!";

console.log(arr); // выведет ['a!', 'b!', 'c!']

// Предыдущий код можно переписать через оператор +=:
let arr = ["a", "b", "c"];

arr[0] += "!";
arr[1] += "!";
arr[2] += "!";

console.log(arr); // выведет ['a!', 'b!', 'c!']
```

---

### Инкремент и декремент элементов массива в JavaScript

Можно также применять операции инкремента и декремента:

```js
let arr = [1, 2, 3, 4];

arr[0]++;
++arr[1];
arr[2]--;
--arr[3];

console.log(arr); // выведет [2, 3, 2, 3]
```

---

### Разреженные массивы в JavaScript

Если в массиве будут ключи с пропусками, то можно получить разреженный массив. Давайте посмотрим, как он выглядит. Пусть у нас есть некоторый массив:

```js
let arr = ["a", "b", "c"];
// Добавим к этому массиву еще один элемент так, чтобы ключи имели пропуски:
arr[4] = "!";

// В результате в массиве образуется дыра, имеющая значение undefined:
console.log(arr); // выведет ['a', 'b', 'c', undefined, '!']

// Длина массива будет вкючать в себя все дыры. То есть в нашем случае она будет 5, а не 4:
console.log(arr.length); // выведет 5
```

---

### Добавление элементов через push в JavaScript

С помощью специального метода push можно добавлять элементы в конец массива. Давайте посмотрим, как это делается. Пусть у нас есть следующий массив:

```js
let arr = [];

// Добавим ему в конец три элемента:
arr.push("a");
arr.push("b");
arr.push("c");

// Посмотрим, что получилось:
console.log(arr); // выведет ['a', 'b', 'c']
```

---

### Оператор delete в массивах в JavaScript

Можно удалять элементы массивов с помощью оператора delete. Давайте посмотрим на примерах. Пусть у нас дан вот такой массив:

```js
let arr = ["a", "b", "c"];

// Давайте удалим один из элементов нашего массива:
delete arr[1];

// В результате элемент удалится, но массив станет разреженным:
console.log(arr); // выведет ['a',, 'c']
```

---

### Объекты в JavaScript

В JavaScript есть специальные структуры данных, которые называются объектами (в других языках программирования они называются ассоциативными массивами или хешами).

Объекты создаются с помощью фигурных скобок { }, внутри которых пишутся элементы этого объекта в формате ключ: значение.

Давайте создадим пустой объект:

```js
let obj = {};

// А теперь создадим объект с данными:
let obj = { 1: "a", 2: "b", 3: "c" };

// Выведем элемент объекта по его ключу:
console.log(obj[1]); // выведет 'a'

// Ключами объектов могут быть строки:
let obj = { a: 1, b: 2, c: 3 };
```

---

### Свойства объектов в JavaScript

Существует альтернативный способ обращения к элементам объекта. В этом способе мы после имени объекта ставим точку и пишем имя ключа. В этом случае ключ называется свойством объекта. Давайте посмотрим, как это делается. Пусть у нас есть следующий объект:

```js
let obj = { a: 1, b: 2, c: 3 };

// Выведем на экран значение его свойства:
console.log(obj.a); // выведет 1
```

---

### Ограничения на ключи объектов в JavaScript

Мы можем писать без кавычек не все ключи объектов, а только те, которые удовлетворяют следующим ограничениям: они не могут начинаться с цифры и не могут содержать внутри себя дефис, пробел и тому подобные вещи.

Если строка нарушает ограничение, то ее нужно брать в кавычки. В следующем примере в часть ключей не удовлетворяет условиям и поэтому стоят в кавычках:

```js
let obj = {'1key': 'a', 'key-2': 'b', key3: 'c'};

// К таким ключам можно обращаться только через квадратные скобки:
console.log(obj['1key']);
console.log(obj['key-2']);

// Также обращение к таким именем через свойство объекта приведет к ошибке:
console.log(obj.1key);
console.log(obj.key-2);

// А вот третий ключ - допустимый, и к нему мы можем обращаться обоими способами:
console.log(obj['key3']);
console.log(obj.key3);
```

---

### Изменение элементов объектов в JavaScript

Элементы объектов можно изменять, обращаясь к ним по ключам. Давайте посмотрим, как это делается. Пусть у нас есть следующий объект:

```js
let obj = { a: 1, b: 2, c: 3 };

// Поменяем значение его элемента:
obj["a"] = "!";

// Воспользуемся обращением через свойство:
obj.b = "!";

// Проверим, изменился ли объект:
console.log(obj);
```

---

### Добавление элементов в объекты в JavaScript

В объекты можно добавлять новые элементы, записывая их в нужные ключи. Давайте посмотрим, как это делается. Пусть у нас есть следующий объект:

```js
let obj = {};

// Добавим в него новые элементы:
obj["a"] = 1;
obj["b"] = 2;
obj["c"] = 3;

// Можно воспользоваться альтернативным синтаксисом:
obj.a = 1;
obj.b = 2;
obj.c = 3;

// Проверим содержимое объекта:
console.log(obj);
```

---

### Массив ключей объекта в JavaScript

Можно получить массив ключей объекта. Давайте посмотрим, как это делается. Пусть у нас есть следующий объект:

```js
let obj = { a: 1, b: 2, c: 3 };

// Получим массив его ключей:
let keys = Object.keys(obj);

// Выведем этот массив в консоль:
console.log(keys);
```

---

### Длина объекта в JavaScript

У объектов нет свойства length, позволяющего найти их длину. Давайте убедимся в этом. Пусть у нас есть следующий объект:

```js
let obj = { a: 1, b: 2, c: 3 };

// Попробуем узнать количество его элементов:
console.log(obj.length); // выведет undefined

// Решим задачу обходным путем - получим массив ключей объекта и найдем его длину:
console.log(Object.keys(obj).length); // выведет 3
```

---

### Вычисляемые свойства в JavaScript

При объявлении объекта имена его свойств могут браться из переменных. Такие свойства называются вычисляемыми. Давайте посмотрим, как это делается. Пусть у нас есть следующий объект:

```js
let obj = {
	a: 1,
	b: 2,
	c: 3,
};

// Пусть имя некоторого свойства хранится в переменной:
let key = "a";

// Давайте сделаем так, чтобы вместо имени свойства взялось значение из нашей переменной. Для этого переменную следует взять в квадратные скобки:
let obj = {
	[key]: 1,
	b: 2,
	c: 3,
};

// При объявлении вычисляемых свойств можно выполнять некоторый код. Пример:
let obj = {
	[key + "1"]: 1,
	[key + "2"]: 2,
	[key + "3"]: 3,
};
```

---

### Оператор in в JavaScript

С помощью оператора in можно проверять наличие свойства в объекте. Давайте посмотрим на примере. Пусть у нас дан вот такой объект:

```js
let obj = { a: 1, b: 2, c: 3 };

// Давайте проверим наличие в нашем объекте какого-нибудь свойства:
console.log("b" in obj); // выведет true

// А теперь выполним проверку для несуществующего свойства:
console.log("x" in obj); // выведет false
```

---

### Оператор delete в JavaScript

Можно удалять элементы объектов с помощью оператора delete. Давайте посмотрим на примерах. Пусть у нас дан вот такой объект:

```js
let obj = { a: 1, b: 2, c: 3 };

// Давайте удалим один из элементов нашего объекта:
delete obj.b;

// Посмотрим, что у нас получилось:
console.log(obj); // выведет {a: 1, c: 3}
```

---

### Типизация объектов в JavaScript

Объекты имеют свой тип данных, который называется 'object'. Проверим с помощью оператора typeof:

```js
console.log(typeof {}); // выведет 'object'

//  Массивы на самом деле являются частным случаем объектов. В этом можно убедится, если проверить массив через оператор typeof:
console.log(typeof []); // выведет 'object'
```

**Данный оператор можно применять ко всем типам данных.**

---

### Отличаем массивы от объектов в JavaScript

Как было указано выше, оператор typeof не позволяет различать массивы и объекты. Иногда, однако, это необходимо сделать. На помощь придет функция Array.isArray():

```js
console.log(Array.isArray([])); // выведет true
console.log(Array.isArray({})); // выведет false
```

---

### Объекты и примитивы в JavaScript

**Объекты (в том числе и массивы, как вы уже знаете) считаются сложными типами данных. Строки, числа, логические значения считаются простыми, или примитивными типами данных. Их часто так и называют - примитивы, подразумевая все то, что не является объектом.**

**В JavaScript семь примитивных типов данных: string, number, boolean, null, undefined, symbol, bigint. Запомните их количество и названия - это часто спрашивают на собеседованиях.**

---

### Передача объектов по ссылке в JavaScript

Массивы и объекты несколько отличаются от остальных примитивных типов данных. Отличие в том, что переменная, хранящая массив, на самом деле не содержит его, а просто ссылается на него.

На практике это означает, что при записи объекта в другую переменную, обе переменных будут ссылаться на один и тот же объект. Давайте попробуем на практике. Пусть у нас есть следующий объект:

```js
let obj1 = { a: 1, b: 2, c: 3 };

// Присвоим его из одной переменной в другую:
let obj2 = obj1;

// Изменим одну из переменных:
obj2.a = "!";

// В результате изменения будут видны и в другой переменной:
console.log(obj1); // {a: '!', b: 2, c: 3}
```

---

### Константы с массивами или объектами в JavaScript

Константы, содержащие массивы и объекты, работают интересным образом. JavaScript не разрешает изменять значения этих констант, но изменять свойства объектов и значения элементов массивов - можно.

Давайте посмотрим на примерах. Пусть у нас дан вот такой объект:

```js
const obj = { a: 1, b: 2, c: 3 };

// Давайте попробуем записать в него что-то другое:
obj = 123; // ошибка

// Давайте попробуем записать в константу другой объект:
obj = { x: 1, y: 2, z: 3 }; // ошибка

// Однако, если мы попробуем изменить свойство объекта, то это сработает:
obj.a = "+"; // работает!
```

---

### Конструкция if-else в JavaScript

Сейчас мы изучим специальную конструкцию if-else, которая позволяет выполнять некоторый код в зависимости от выполнения какого-либо условия.

С помощью конструкции if-else мы можем задать программе, к примеру, вопрос "больше ли переменная a, чем переменная b", и в зависимости от ответа выполнить или один код, или другой.

Синтаксис конструкции выглядит так:

```js
if (операция сравнения) {
	/*
		расположенный здесь код выполниться,
		если результат операция сравнения верный
	*/
} else {
	/*
		расположенный здесь код выполниться,
		если результат операция сравнения неверный
	*/
}
```

Для операций сравнения в JavaScript существует много операторов. Давайте приступим к их изучению.

---

### Операторы больше и меньше в JavaScript

Для проверки того, которое из значений больше, а которое меньше, используются операторы больше >, больше или равно >=, меньше <, меньше или равно <=.

```js
let test = 1;

if (test > 0) {
	console.log("+++"); // сработает это
} else {
	console.log("---");
}
```

---

### Проверка на равенство в JavaScript

Для проверки двух значений на равенство используется оператор ==. Давайте для примера проверим, что test переменная равна 0:

```js
let test = 0;

if (test == 0) {
	console.log("+++"); // сработает это
} else {
	console.log("---");
}
```

---

### Сравнение переменных в JavaScript

В примерах выше мы сравнивали переменную с каким-то числом. Но никто не запрещает нам сравнивать две переменные. Смотрите пример:

```js
let test1 = 1;
let test2 = 2;

if (test2 > test1) {
	console.log("+++"); // сработает это
} else {
	console.log("---");
}
```

---

Равенство строк в JavaScript

При использовании конструкции if можно сравнивать и строки. Для примера пусть в переменной test хранится какая-то строка, например 'abc'.

Давайте проверим, равно ли содержимое переменной test строке 'abc':

```js
let test = "abc";

if (test == "abc") {
	console.log("+++"); // сработает это
} else {
	console.log("---");
}
```

---

### Проверка на неравенство в JavaScript

Оператор != проверяет на неравенство. Давайте для примера проверим, что переменная test не равна 0:

```js
let test = 1;

if (test != 0) {
	console.log("+++"); // сработает это
} else {
	console.log("---");
}
```

---

### Равенство строк и чисел в JavaScript (не строго стравнение)

Как вы знаете, число в кавычках представляет собой строку. Например, '3' - это строка. Однако, при сравнении таких строк с настоящими числами JavaScript считает, что строка в кавычках равна такому же числу.

Давайте для примера сравним строку '3' и число 3:

```js
if ("3" == 3) {
	console.log("+++"); // сработает это
} else {
	console.log("---");
}
```

---

### Равенство по значению и типу в JavaScript (строго сравнение)

Пусть вы хотите сравнивать так, чтобы число в кавычках не было равно такому же числу без кавычек. Говоря другими словами, вы хотите сравнивать так, чтобы сравнение было не только по значению, но и по типу данных.

Для этого вместо оператора == следует использовать оператор ===. В следующем примере при сравнении строки '3' и числа 3 условие будет ложным, так как переменные, хотя и равны по значению, но не равны по типу:

```js
if ("3" === 3) {
	console.log("+++");
} else {
	console.log("---"); // сработает это
}
```

Разница между оператором `==` и оператором `===` проявляется именно тогда, когда значения одинаковые, но разный тип данных. В остальных случаях эти операторы работают одинаково.

**Рекомендуется использовать строго сравнение**

---

### Неравенство по значению и типу в JavaScript

Кроме оператора != существует также оператор !==, учитывающий тип при сравнении. Давайте рассмотрим различия между ними на примерах.

Пусть с помощью оператора != сравниваются два числа 3. Данный оператор сравнивает значения на то, что они НЕ равны. Так как наши значения как раз-таки равны, то условие будет ложным:

```js
if (3 != 3) {
	console.log("+++");
} else {
	console.log("---"); // сработает это
}
```

---

### Логическое И в JavaScript

Можно группировать операции сравнения с помощью оператора &&, представляющего собой логическое И. В следующем примере, если переменная num больше нуля и одновременно меньше 10, только тогда выведется '+++':

```js
let num = 3;

if (num > 0 && num < 10) {
	console.log("+++");
} else {
	console.log("---");
}

// Условия могут налагаться не на одну переменную, а на разные. В следующем примере, если переменная num1 равна 2 и одновременно переменная num2 равна 3, только тогда условие будет истинно:
let num1 = 2;
let num2 = 3;

if (num1 == 2 && num2 == 3) {
	console.log("+++");
} else {
	console.log("---");
}
```

---

### Логическое ИЛИ в JavaScript

Оператор || представляет собой логическое ИЛИ и требует выполнения хотя бы одного условия.

В следующем примере, если переменная num1 больше 0 или переменная num2 больше 0, то условие будет истинно (достаточно выполнения хотя бы одного из условий):

```js
let num1 = 10;
let num2 = -5;

if (num1 > 0 || num2 > 0) {
	console.log("+++"); // сработает это
} else {
	console.log("---");
}
```

---

### Приоритет логических операторов в JavaScript

Операция && имеет приоритет над ||. В следующем примере условие будет истинно, если переменная num от 0 до 5 ИЛИ от 10 до 20:

```js
let num = 3;

if ((num > 0 && num < 5) || (num > 10 && num < 20)) {
	console.log("+++");
} else {
	console.log("---");
}
```

---

### Группировка условий в JavaScript

Хотя операция && и имеет приоритет над ||, часто удобнее использовать группирующие круглые скобки, чтобы явно показать приоритет операций:

```js
let num = 3;

if ((num > 0 && num < 5) || (num > 10 && num < 20)) {
	console.log("+++");
} else {
	console.log("---");
}

// Конечно же, группировка может быть использована и в том случае, когда вам нужен свой приоритет операций, а не тот, который получается по умолчанию:
let num1 = 3;
let num2 = 5;

if (num1 > 0 && (num2 == 3 || num2 == 5)) {
	console.log("+++");
} else {
	console.log("---");
}
```

---

### Инвертирование логических выражений в JavaScript

Рассмотрим следующий код:

```js
if (num > 0 && num < 5) {
	console.log("+++");
} else {
	console.log("---");
}
```

Сейчас наше условие такое: num должно быть от 0 до 5. Давайте инвертируем это условие, то есть превратим его в его противоположность. Противоположное условие получится таким: num должно быть меньше или равно 0 ИЛИ больше или равно 5:

```js
if (num <= 0 || num >= 5) {
	console.log("+++");
} else {
	console.log("---");
}

// Как вы видите, чтобы инвертировать условие, приходится несколько задуматься. Гораздо проще будет использовать оператор !, представляющий собой логическое НЕ. С помощью этого оператора нам достаточно поставить знак ! перед изначальным условием - и оно инвертируется само:
if (!(num > 0 && num < 5)) {
	console.log("+++");
} else {
	console.log("---");
}
```

---

### Условия с булевыми значениями в JavaScript

Пусть у нас есть какая-то переменная, которая может принимать значения true или false:

```js
let test = true;

// Давайте напишем if, проверяющий нашу переменную на значение true:
let test = true;

if (test === true) {
	console.log("+++");
} else {
	console.log("---");
}
```

---

### Сокращенная форма проверки на истину в JavaScript

Пусть мы хотим узнать, равна ли переменная test значению true. В этом случае конструкцию if можно записать так:

```js
let test = true;

if (test == true) {
	console.log("+++");
} else {
	console.log("---");
}
```

При программировании такие проверки требуются очень часто, поэтому для них существует более изящная сокращенная форма: вместо if (test == true) можно написать просто if (test).

Давайте перепишем наш код в сокращенной форме:

```js
let test = true;

if (test) {
	console.log("+++");
} else {
	console.log("---");
}
```

---

### Сокращенная форма проверки на ложь в JavaScript

Пусть теперь мы хотим проверить значение переменной на ложь. Это можно сделать следующим образом:

```js
let test = true;

if (test === false) {
	console.log("+++");
} else {
	console.log("---");
}
```

Можно также написать эквивалентный код с отрицанием:

```js
let test = true;

if (test !== true) {
	console.log("+++");
} else {
	console.log("---");
}
```

Приведенный код может быть переписан в сокращенной форме следующим образом:

```js
let test = true;

if (!test) {
	console.log("+++");
} else {
	console.log("---");
}
```

---

### Конструкция else if в JavaScript

Конструкция else if позволяет задавать условия в блоке else. Давайте посмотрим на примере:

```js
let num = 1;

if (num == 1) {
	console.log("value1");
} else if (num == 2) {
	console.log("value2");
} else if (num == 3) {
	console.log("value3");
}
```

Преимуществом использования else if вместо нескольких ифов является возможность отловить ситуацию, когда значение переменной num не подходит ни под одно из условий:

```js
let num = 1;

if (num == 1) {
	console.log("value1");
} else if (num == 2) {
	console.log("value2");
} else if (num == 3) {
	console.log("value3");
} else {
	console.log("неверное значение переменной num");
}
```

Конструкции if-else можно вкладывать друг в друга произвольным образом.

---

### Конструкция switch-case в JavaScript

С помощью конструкции switch-case можно выполнять различный код, в зависимости от значения переменной. Вот синтаксис этой конструкции:

```js
switch (переменная) {
	case "значение1":
		/*
			здесь код, который выполнится в случае,
			если переменная имеет значение1
		*/
		break;
	case "значение2":
		/*
			здесь код, который выполнится в случае,
			если переменная имеет значение2
		*/
		break;
	case "значение3":
		/*
			здесь код, который выполнится в случае,
			если переменная имеет значение3
		*/
		break;
	default:
		/*
			здесь код, который выполнится в случае,
			если не совпала ни с одним значением
		*/
		break;
}
```

Напишем пример кода с конструкцией switch-case:

```js
let num = 1;

switch (num) {
	case 1:
		console.log("value1");
		break;
	case 2:
		console.log("value2");
		break;
	case 3:
		console.log("value3");
		break;
	default:
		console.log("incorrect value");
		break;
}
```

---

### Необязательность break в конструкции switch-case в JavaScript

Команда break в конструкции switch-case не является обязательной. При отсутствии break после выполнения задуманного case, выполнятся и все case ниже него.

Давайте посмотрим на примере:

```js
let num = 1; // пусть здесь число 1

switch (num) {
	case 1:
		console.log(1); // сработает это
	case 2:
		console.log(2); // сработает и это
	case 3:
		console.log(3); // сработает и это
}
```

_Иногда очевиднее задачи решать через if: _

---

### Тернарный оператор в JavaScript

В данном уроке мы рассмотрим специальный тернарный оператор, представляющий собой сокращенный вариант конструкции if-else. Его синтаксис выглядит следующим образом:
let переменная = условие ? значение1 : значение2;

Оператор работает так: если условие истинно, то возвращается значение1, в противном случае - значение2. Давайте сделаем пример кода с использованием данного оператора:

```js
let age = 17;
let adult = age >= 18 ? true : false;
console.log(adult);
```

Этот код в полном виде можно переписать следующим образом:

```js
let age = 17;
let adult;

if (age >= 18) {
	adult = true;
} else {
	adult = false;
}

console.log(adult);
```

    Тернарный оператор следует использовать только в самых простых случаях, так как его использование затрудняет понимание кода.

---

### Область видимости

Область видимости в JavaScript определяет, в каком участке кода переменная или функция доступны для использования. Вот основные виды областей видимости:

- **Глобальная область видимости:**  
  Переменные, объявленные вне всех функций и блоков, доступны во всём коде.

- **Функциональная область видимости:**  
  Переменные, объявленные с помощью `var` внутри функции, доступны только в этой функции.

- **Блочная область видимости:**  
  Переменные, объявленные с помощью `let` или `const` внутри блока (например, в `{}` после `if`, `for`), доступны только в пределах этого блока.

Эта концепция помогает избежать конфликтов имён и контролировать, где и как используются данные переменные.

---

Ниже приведён пример кода, демонстрирующий различные области видимости в JavaScript:

```javascript
// Глобальная область видимости
var globalVar = "Я глобальная переменная";

function demoFunction() {
	// Функциональная область видимости (доступна только внутри функции)
	var functionVar = "Я переменная в функции";

	console.log(globalVar); // Выведет: Я глобальная переменная
	console.log(functionVar); // Выведет: Я переменная в функции

	if (true) {
		// Блочная область видимости (доступна только внутри блока)
		let blockLet = "Я переменная в блоке с let";
		const blockConst = "Я переменная в блоке с const";

		console.log(blockLet); // Выведет: Я переменная в блоке с let
		console.log(blockConst); // Выведет: Я переменная в блоке с const
	}

	// Попытка обратиться к переменным blockLet или blockConst здесь вызовет ошибку,
	// так как они доступны только внутри блока if.
	// console.log(blockLet);  // Uncaught ReferenceError: blockLet is not defined
}

demoFunction();

// Переменная functionVar недоступна вне функции demoFunction.
// console.log(functionVar);  // Uncaught ReferenceError: functionVar is not defined

// Глобальная переменная доступна в любом месте кода.
console.log(globalVar); // Выведет: Я глобальная переменная
```

### Объяснение:

- **Глобальная область видимости:**  
  Переменная `globalVar` объявлена вне функций, поэтому доступна во всём коде.

- **Функциональная область видимости:**  
  Переменная `functionVar` объявлена с помощью `var` внутри функции `demoFunction` и доступна только внутри этой функции.

- **Блочная область видимости:**  
  Переменные `blockLet` и `blockConst` объявлены с помощью `let` и `const` внутри блока `if`, поэтому доступны только внутри этого блока.

Такая организация областей видимости помогает избежать конфликтов имен и нежелательного доступа к переменным вне их контекста.

---

### Область видимости переменных в if-else в JavaScript

Пусть для простоты у нас есть всегда выполняющееся условие:

```js
if (true) {
}
```

Давайте рассмотрим следующий код:

```js
if (true) {
	let res = "!";
}
console.log(res);
```

Как вы видите, в переменную res должно записаться значение '!'. Однако, если запустить этот код, то в консоль выведется ошибка!

Дело в том, что переменные, объявленные внутри фигурных скобок, видны только внутри этих скобок, и не видны снаружи. По-научному здесь идет речь об области видимости переменных.

Можно говорить о том, что областью видимости переменных, объявленных внутри фигурных скобок, являются только эти фигурные скобки. Однако, если переменная объявлена снаружи фигурных скобок, то видна и внутри них, и снаружи:
let res; // переменная объявлена снаружи

```js
if (true) {
	res = "!";
}

console.log(res); // выведет '!'
```

В следующем примере в переменную res в зависимости от условия записывается либо значение 1, либо значение 2:

```js
let num = 5;

if (num >= 0) {
	let res = 1;
} else {
	let res = 2;
}

console.log(res);
```

Однако, если запустить этот код, то в консоль выведется ошибка. Как вы теперь уже понимаете, все дело в видимости переменных. Для решения проблемы объявим переменную снаружи условия:

```js
let test = true;
let res; // объявим переменную снаружи условия

if (test) {
	res = 1;
} else {
	res = 2;
}

console.log(res); // выведет 1
```

---

### Проверка остатка от деления в JavaScript

Пусть у нас есть две переменные с числами:

```js
let a = 10;
let b = 3;
```

Давайте найдем остаток от деления одной переменной на другую:

```js
let a = 10;
let b = 3;

console.log(a % b); // выведет 1
```

Пусть теперь в переменных хранятся такие значения, что одна переменная делится на вторую нацело:

```js
let a = 10;
let b = 5;

console.log(a % b); // выведет 0
```

Давайте напишем скрипт, который будет проверять, делится ли нацело одно число на второе:

```js
let a = 10;
let b = 3;

if (a % b === 0) {
	console.log("делится нацело");
} else {
	console.log("делится с остатком");
}
```

Пусть теперь требуется, если число делится с остатком, вывести этот остаток в консоль:

```js
let a = 10;
let b = 3;

if (a % b === 0) {
	console.log("делится нацело");
} else {
	console.log("делится с остатком " + (a % b));
}
```

В приведенном выше коде получается, что остаток вычисляется в двух местах, а это не оптимально. Поправим проблему:

```js
let a = 10;
let b = 3;
let rest = a % b;

if (rest === 0) {
	console.log("делится нацело");
} else {
	console.log("делится с остатком " + rest);
}
```

---

### Задачи на отработку

### Задачи

3. Напишите программу, которая из строки, содержащей текст и цифры (например, "Привет123мир456"), извлекает все числа и возвращает массив чисел [123, 456].

---

_Средний уровень_

### 4. Задача. Работа с массивами

Создайте массив чисел.

1. Измените второй элемент массива на новое число.
2. Используйте метод `push` для добавления нового элемента в конец массива.
3. Пройдитесь циклом по массиву и выполните инкремент каждого элемента (например, увеличьте значение на 1).
4. Выведите итоговый массив в консоль.

Используйте цикл `for`.

---

### Задача 5. Разреженные массивы и оператор `delete`

Создайте массив из 5 элементов.

1. Удалите третий элемент массива с помощью оператора `delete`.
2. Пройдитесь циклом по массиву (например, используя метод `forEach` или `for...of`) и выведите в консоль каждый элемент, объяснив, почему некоторые элементы могут быть пропущены.

### Задача 6. Работа с объектами: изменение, добавление и вычисляемые свойства

1. Создайте объект, содержащий свойства: `name`, `age` и `city`.
2. Измените значение свойства `city`.
3. Добавьте новое свойство, используя вычисляемое имя (например, ключ берётся из переменной).
4. Выведите массив ключей объекта с помощью `Object.keys()` и его длину.

_Подсказка:_  
Запишите вычисляемое свойство так:

```javascript
let propName = "country";
object[propName] = "Россия";
```

### Задача 7. Область видимости переменных в условных конструкциях

**Описание:**  
Напишите код, который:

1. Объявляет переменную с помощью `let` внутри блока `if` и пытается обратиться к ней вне этого блока.
2. Объявляет переменную с помощью `var` в том же блоке и затем выводит её значение за пределами блока.
3. Прокомментируйте, почему переменная, объявленная через `let`, недоступна вне блока, а переменная через `var` доступна.

_Подсказка:_  
Запишите два блока кода и используйте комментарии для объяснения поведения.

---

## Сложный уровень

### Задача 6. Расширенная работа с разреженными массивами

**Описание:**

1. Создайте массив с элементами на позициях 0, 2, 4 (оставив «дырки» на нечетных индексах).
2. Используйте оператор `delete` для удаления элемента на позиции 2.
3. Выведите исходный и итоговый массивы в консоль.

---

Все задачи нужно выполнять в отдельных файлах `task_n.js`, где `n` — номер части учебника. Не забывайте подключать файлы в `index.html`.
